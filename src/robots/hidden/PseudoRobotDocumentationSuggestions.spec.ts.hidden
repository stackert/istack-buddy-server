import { PseudoRobotDocumentationSuggestions } from './PseudoRobotDocumentationSuggestions.ts.hidden';
import { TMessageEnvelope, TRobotMessage } from './types';

describe('PseudoRobotDocumentationSuggestions', () => {
  let robot: PseudoRobotDocumentationSuggestions;

  beforeEach(() => {
    robot = new PseudoRobotDocumentationSuggestions();
  });

  describe('Class Properties', () => {
    it('should have correct name property', () => {
      expect(robot.name).toBe('PseudoRobotDocumentationSuggestions');
    });

    it('should have correct version property', () => {
      expect(robot.version).toBe('1.0.0');
    });

    it('should have correct LLModelName property', () => {
      expect(robot.LLModelName).toBe('pseudo-documentation');
    });

    it('should have correct LLModelVersion property', () => {
      expect(robot.LLModelVersion).toBe('1.0.0');
    });

    it('should have correct contextWindowSizeInTokens property', () => {
      expect(robot.contextWindowSizeInTokens).toBe(4096);
    });

    it('should inherit getName method from AbstractRobot', () => {
      expect(robot.getName()).toBe('PseudoRobotDocumentationSuggestions');
    });

    it('should inherit getVersion method from AbstractRobot', () => {
      expect(robot.getVersion()).toBe('1.0.0');
    });

    it('should have correct robotClass property', () => {
      expect(robot.robotClass).toBe('PseudoRobotDocumentationSuggestions');
    });
  });

  describe('Static Properties', () => {
    it('should have static descriptionShort property', () => {
      expect(
        PseudoRobotDocumentationSuggestions.descriptionShort,
      ).toBeDefined();
      expect(typeof PseudoRobotDocumentationSuggestions.descriptionShort).toBe(
        'string',
      );
      expect(
        PseudoRobotDocumentationSuggestions.descriptionShort.trim().length,
      ).toBeGreaterThan(0);
    });

    it('should have static descriptionLong property', () => {
      expect(PseudoRobotDocumentationSuggestions.descriptionLong).toBeDefined();
      expect(typeof PseudoRobotDocumentationSuggestions.descriptionLong).toBe(
        'string',
      );
      expect(
        PseudoRobotDocumentationSuggestions.descriptionLong.trim().length,
      ).toBeGreaterThan(0);
    });

    it('should have descriptionLong longer than descriptionShort', () => {
      const shortLength =
        PseudoRobotDocumentationSuggestions.descriptionShort.trim().length;
      const longLength =
        PseudoRobotDocumentationSuggestions.descriptionLong.trim().length;
      expect(longLength).toBeGreaterThan(shortLength);
    });
  });

  describe('estimateTokens', () => {
    it('should estimate tokens correctly for normal messages', () => {
      const message = 'This is a test message';
      const estimatedTokens = robot.estimateTokens(message);
      const expectedTokens = Math.ceil(message.length / 4);
      expect(estimatedTokens).toBe(expectedTokens);
    });

    it('should handle empty strings', () => {
      expect(robot.estimateTokens('')).toBe(0);
    });

    it('should handle very long messages', () => {
      const longMessage = 'A'.repeat(1000);
      const estimatedTokens = robot.estimateTokens(longMessage);
      expect(estimatedTokens).toBe(250); // 1000 / 4
    });
  });

  describe('acceptMessageMultiPartResponse', () => {
    let mockMessageEnvelope: TMessageEnvelope;
    let mockRobotMessage: TRobotMessage;
    let mockDelayedCallback: jest.Mock;

    beforeEach(() => {
      mockRobotMessage = {
        message: 'I need help with documentation',
        content: 'I need help with documentation',
        sender: 'user123',
        receiver: 'robot',
        timestamp: '2024-01-01T10:00:00Z',
        created_at: '2024-01-01T10:00:00Z',
        role: 'user',
      };

      mockMessageEnvelope = {
        routerId: 'router-123',
        messageType: 'message',
        message: mockRobotMessage,
      };

      mockDelayedCallback = jest.fn();
      jest.useFakeTimers();
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('should return a promise that resolves with immediate response', async () => {
      const result = await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        mockDelayedCallback,
      );

      expect(result).toBeDefined();
      expect(result.routerId).toBe('router-123');
      expect(result.messageType).toBe('response');
      expect(result.message?.sender).toBe(
        'PseudoRobotDocumentationSuggestions',
      );
    });

    it('should provide immediate response with analysis message', async () => {
      const result = await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        mockDelayedCallback,
      );

      expect(result.message?.content).toContain(
        'Analyzing documentation needs',
      );
      expect(result.message?.content).toContain(
        'I need help with documentation',
      );
      expect(result.message?.message).toContain(
        'Analyzing documentation needs and preparing suggestions',
      );
    });

    it('should call delayed callback with documentation suggestions', async () => {
      await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        mockDelayedCallback,
      );

      // Fast forward through the first delayed response (1200ms)
      jest.advanceTimersByTime(1200);

      expect(mockDelayedCallback).toHaveBeenCalledTimes(1);
      const firstCallArg = mockDelayedCallback.mock.calls[0][0];
      expect(firstCallArg.message?.content).toContain(
        'Documentation Suggestions',
      );
      expect(firstCallArg.message?.message).toContain(
        'Found 5 relevant documentation resources',
      );
    });

    it('should call delayed callback twice with different responses', async () => {
      await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        mockDelayedCallback,
      );

      // Fast forward through both delayed responses
      jest.advanceTimersByTime(3000);

      expect(mockDelayedCallback).toHaveBeenCalledTimes(2);

      const firstCall = mockDelayedCallback.mock.calls[0][0];
      const secondCall = mockDelayedCallback.mock.calls[1][0];

      expect(firstCall.message?.content).toContain('Documentation Suggestions');
      expect(secondCall.message?.content).toContain('Documentation Categories');
    });

    it('should include expected documentation URLs in responses', async () => {
      await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        mockDelayedCallback,
      );

      jest.advanceTimersByTime(3000);

      const responses = mockDelayedCallback.mock.calls.map((call) => call[0]);
      const allContent = responses.map((r) => r.message?.content).join(' ');

      expect(allContent).toContain(
        'https://example.com/istack-pseudo/document-one.html',
      );
      expect(allContent).toContain(
        'https://example.com/istack-pseudo/document-two.html',
      );
      expect(allContent).toContain(
        'https://example.com/istack-pseudo/document-three.html',
      );
    });

    it('should handle empty message content', async () => {
      mockMessageEnvelope.message = {
        ...mockRobotMessage,
        message: '',
        content: '',
      };

      const result = await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        mockDelayedCallback,
      );

      expect(result).toBeDefined();
      expect(result.message?.content).toContain(
        'Analyzing documentation needs for: ""',
      );
    });

    it('should handle missing message content gracefully', async () => {
      mockMessageEnvelope.message = {
        ...mockRobotMessage,
        message: undefined,
        content: undefined,
      };

      const result = await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        mockDelayedCallback,
      );

      expect(result).toBeDefined();
      expect(result.message?.content).toContain(
        'Analyzing documentation needs for: ""',
      );
    });

    it('should handle callback errors gracefully', async () => {
      const errorCallback = jest.fn().mockImplementation(() => {
        throw new Error('Callback error');
      });

      const result = await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        errorCallback,
      );

      expect(result).toBeDefined();

      // Should not throw even if callback throws
      expect(() => {
        jest.advanceTimersByTime(3000);
      }).not.toThrow();
    });

    it('should work with null callback', async () => {
      const result = await robot.acceptMessageMultiPartResponse(
        mockMessageEnvelope,
        null as any,
      );

      expect(result).toBeDefined();
      expect(() => {
        jest.advanceTimersByTime(3000);
      }).not.toThrow();
    });
  });

  describe('Inheritance and Type Checking', () => {
    it('should be an instance of PseudoRobotDocumentationSuggestions', () => {
      expect(robot).toBeInstanceOf(PseudoRobotDocumentationSuggestions);
    });

    it('should have the correct constructor name', () => {
      expect(robot.constructor.name).toBe(
        'PseudoRobotDocumentationSuggestions',
      );
    });
  });

  describe('Documentation Links Structure', () => {
    it('should have access to internal documentation links', async () => {
      // Test by checking the output contains expected structure
      const mockEnvelope: TMessageEnvelope = {
        routerId: 'test',
        messageType: 'message',
        message: {
          message: 'test',
          content: 'test',
          sender: 'user',
          receiver: 'robot',
          timestamp: '2024-01-01T10:00:00Z',
          created_at: '2024-01-01T10:00:00Z',
          role: 'user',
        },
      };

      const callback = jest.fn();
      jest.useFakeTimers();

      await robot.acceptMessageMultiPartResponse(mockEnvelope, callback);
      jest.advanceTimersByTime(3000);

      expect(callback).toHaveBeenCalled();
      const responses = callback.mock.calls.map(
        (call) => call[0].message?.content,
      );
      const allContent = responses.join(' ');

      // Check for expected categories
      expect(allContent).toContain('Getting Started');
      expect(allContent).toContain('Development');
      expect(allContent).toContain('Reference');
      expect(allContent).toContain('Best Practices');
      expect(allContent).toContain('Support');

      jest.useRealTimers();
    });
  });
});
