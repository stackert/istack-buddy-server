import { Injectable, Logger } from '@nestjs/common';
import { ChatManagerService } from '../chat-manager/chat-manager.service';
import { RobotProcessorService } from '../chat-manager/robot-processor.service';
import { MessageType, UserRole } from '../chat-manager/dto/create-message.dto';
import { StartConversationDto } from '../chat-manager/dto/start-conversation.dto';
import { Conversation } from '../chat-manager/interfaces/message.interface';
import { createHash } from 'crypto';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';

// Types for conversation context
interface ConversationContext {
  type: 'channel_mention' | 'thread_reply' | 'external_thread';
  action: 'Creating' | 'Adding to existing';
  conversationId?: string; // Will be generated by ChatManager if creating new
  slackThreadTs: string; // Slack thread timestamp for tracking
  responseThreadTs: string; // Where to send the response
  isNewConversation: boolean;
}

// Enhanced event deduplication information
interface EventDeduplicationInfo {
  eventId: string;
  contentHash: string;
  timestamp: number;
  eventTime?: number;
  processedAt: number;
}

/**
 * Slack API Service
 * Handles webhook events from Slack workspace
 * Uses single ChatManager system for conversation management
 */
@Injectable()
export class IstackBuddySlackApiService {
  private readonly logger = new Logger(IstackBuddySlackApiService.name);

  // private readonly processedEvents = new Map<string, EventDeduplicationInfo>();
  private readonly eventCleanupInterval = 60000; // 1 minute
  private readonly eventRetentionTime = 300000; // 5 minutes (300 seconds)

  // Map Slack thread timestamps to ChatManager conversation IDs
  private readonly slackThreadToConversationMap: Record<string, string> = {};

  constructor(
    private readonly chatManagerService: ChatManagerService,
    private readonly robotProcessorService: RobotProcessorService,
  ) {
    // Ensure logging directory exists
    this.ensureLoggingDirectoryExists();

    // Clean up old processed events and slack mappings every minute
    setInterval(() => {
      this.routineGarbageCollection();
    }, this.eventCleanupInterval);
  }

  /**
   * Ensure the logging directory exists
   */
  private ensureLoggingDirectoryExists(): void {
    const loggingDir = join(
      process.cwd(),
      'docs-living',
      'debug-logging',
      'conversations',
    );

    if (!existsSync(loggingDir)) {
      mkdirSync(loggingDir, { recursive: true });
      this.logger.log(`Created logging directory: ${loggingDir}`);
    }
  }

  /**
   * Log ALL incoming Slack events to file system
   * Captures RAW request data before any processing
   */
  private async logSlackEvent(body: any): Promise<void> {
    try {
      const unixTimestamp = Math.floor(Date.now() / 1000);
      const logFilename = `${unixTimestamp}.slack.log.json`;
      const logPath = join(
        process.cwd(),
        'docs-living',
        'debug-logging',
        'conversations',
        logFilename,
      );

      // Write to file
      writeFileSync(logPath, JSON.stringify(body, null, 2), 'utf8');
    } catch (error) {
      this.logger.error('Error logging Slack event:', error);
    }
  }

  /**
   * Handle incoming Slack events
   * Main entry point for all Slack webhook events
   */
  async handleSlackEvent(req: any, res: any): Promise<void> {
    try {
      // üìù LOG ALL INCOMING EVENTS FIRST (before any processing)
      const body = req.body;
      await this.logSlackEvent(body);

      // Handle URL verification challenge
      if (body.challenge) {
        // Slack initiation/setup requirement to verify URL
        res.status(200).json({ challenge: body.challenge });
        return;
      }

      // Enhanced logging of full event structure for debugging
      this.logger.log('Received Slack event:', {
        eventType: body.event?.type,
        eventId: body.event_id,
        eventTime: body.event_time,
        teamId: body.team_id,
        eventTs: body.event?.ts,
        eventUser: body.event?.user,
        eventChannel: body.event?.channel,
        eventText: body.event?.text?.substring(0, 100) + '...',
      });

      // Handle app mention events
      if (body.event && body.event.type === 'app_mention') {
        this.logger.log('üì¢ Received app mention event');
        await this.handleAppMention(body.event, body.event_time, body.event_id);
        res.status(200).json({ status: 'ok' });
        return;
      }

      // Handle other event types
      // this gets logged above
      // this.logger.log(`Received event type: ${body.event?.type || 'unknown'}`);
      res.status(200).json({ status: 'ok' });
    } catch (error) {
      this.logger.error('Error handling Slack event:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle Slack app mentions (@istackbuddy)
   * Implements conversation continuity with smart thread handling:
   * - Mention in channel ‚Üí New conversation + start thread
   * - Mention in our thread ‚Üí Add to existing conversation
   * - Mention in external thread ‚Üí New conversation
   */
  private async handleAppMention(
    event: any,
    eventTime?: number,
    eventId?: string,
  ): Promise<void> {
    // Declare conversationContext outside try block for error handling access
    let conversationContext: ConversationContext | undefined;

    try {
      // Mark event as processed

      this.logger.log(
        `Received mention from user ${event.user} in channel ${event.channel}`,
      );
      this.logger.log(`üìÑ Message text: "${event.text}"`);

      // DETERMINE CONVERSATION CONTEXT
      conversationContext = this.determineConversationContext(event);
      this.logger.log(`Conversation context: ${conversationContext.type}`);
      this.logger.log(`Conversation ID: ${conversationContext.conversationId}`);

      if (!conversationContext.isNewConversation) {
        this.logger.log(
          `Existing conversation: ${conversationContext.conversationId}`,
        );
      }

      // IMMEDIATE ACKNOWLEDGMENT - Add thinking emoji reaction
      await this.addSlackReaction('thinking_face', event.channel, event.ts);

      // üè† STEP 1: Create/get conversation in ChatManager
      const conversation = await this.getOrCreateConversationForContext(
        conversationContext,
        event.user,
      );

      // üìù STEP 2: Add user message to conversation
      const userMessage = await this.chatManagerService.addExternalMessage(
        conversation.id,
        event.user,
        event.text,
        MessageType.TEXT,
        UserRole.CUSTOMER,
        UserRole.AGENT,
      );

      // STEP 3: Process message with robot (external)
      this.logger.log('Processing message with robot...');
      const robotResponse =
        await this.robotProcessorService.processSlackMention(
          event.text,
          event.user,
          conversation.id,
          async (delayedResponse) => {
            // Handle delayed responses (tool results) - send immediately to Slack
            this.logger.log('Sending delayed response to Slack...');
            await this.sendSlackMessage(
              delayedResponse.response,
              event.channel,
              conversationContext?.responseThreadTs || event.ts,
            );

            // Also add to conversation for tracking
            await this.chatManagerService.addExternalMessage(
              conversation.id,
              delayedResponse.robotName,
              delayedResponse.response,
              MessageType.TEXT,
              UserRole.ROBOT,
              UserRole.SYSTEM_DEBUG,
            );
          },
        );

      this.logger.log(
        `Robot response: ${robotResponse.robotName} (${robotResponse.processed ? 'success' : 'failed'})`,
      );

      // STEP 4: Add robot response to conversation
      this.logger.log('Adding robot response to conversation...');
      const robotMessage = await this.chatManagerService.addExternalMessage(
        conversation.id,
        robotResponse.robotName,
        robotResponse.response,
        MessageType.TEXT,
        UserRole.ROBOT,
        UserRole.SYSTEM_DEBUG,
      );

      this.logger.log(`Robot message added: ${robotMessage.id}`);

      // üì≤ STEP 5: Send robot response to Slack (in correct thread)
      this.logger.log('Sending response to Slack...');
      const responseThreadTs = conversationContext.responseThreadTs || event.ts;
      this.logger.log(`Response will be sent to thread: ${responseThreadTs}`);
      await this.sendSlackMessage(
        robotResponse.response,
        event.channel,
        responseThreadTs,
      );

      this.logger.log('App mention processing completed successfully');
    } catch (error) {
      this.logger.error('Error handling app mention:', error);

      // Send error message to Slack (in correct thread)
      try {
        const responseThreadTs =
          conversationContext?.responseThreadTs || event.ts;
        await this.sendSlackMessage(
          `Sorry, I encountered an error processing your request: ${error instanceof Error ? error.message : 'Unknown error'}`,
          event.channel,
          responseThreadTs,
        );
      } catch (sendError) {
        this.logger.error('Failed to send error message to Slack:', sendError);
      }
    }
  }

  /**
   * Send a message to Slack channel
   */
  private async sendSlackMessage(
    message: string,
    channelId: string,
    thread_ts: string,
  ) {
    try {
      const response = await fetch('https://slack.com/api/chat.postMessage', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${process.env.SLACK_BOT_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          channel: channelId,
          text: message,
          thread_ts: thread_ts,
        }),
      });

      if (response.ok) {
        const responseData = await response.json();
        if (responseData.ok) {
          this.logger.log(`Message sent to Slack channel ${channelId}`);
        } else {
          this.logger.error(`Slack API error: ${responseData.error}`);
        }
      } else {
        this.logger.error(
          `HTTP error: ${response.status} ${response.statusText}`,
        );
      }
    } catch (error) {
      this.logger.error('Error sending message to Slack:', error);
    }
  }

  /**
   * Add an emoji reaction to a Slack message
   */
  private async addSlackReaction(
    emojiName: string,
    channelId: string,
    timestamp: string,
  ) {
    try {
      this.logger.log(
        `Adding reaction :${emojiName}: to message ${timestamp} in channel ${channelId}`,
      );

      const response = await fetch('https://slack.com/api/reactions.add', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${process.env.SLACK_BOT_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          channel: channelId,
          name: emojiName, // emoji name without colons
          timestamp: timestamp,
        }),
      });

      const responseData = await response.json();

      if (response.ok && responseData.ok) {
        this.logger.log(
          `Added reaction :${emojiName}: to message in channel ${channelId}`,
        );
      } else {
        this.logger.error(
          `Failed to add reaction: ${responseData.error || 'Unknown error'}`,
        );
        this.logger.error(`Response status: ${response.status}`);
        this.logger.error(`Response data:`, responseData);
      }
    } catch (error) {
      this.logger.error('Error adding reaction:', error);
    }
  }

  /**
   * Test method to debug reaction functionality
   */
  async testReaction(channelId: string, timestamp: string, emojiName: string) {
    this.logger.log(
      `üß™ Testing reaction API with channel: ${channelId}, timestamp: ${timestamp}, emoji: ${emojiName}`,
    );

    try {
      await this.addSlackReaction(emojiName, channelId, timestamp);
      return {
        success: true,
        message: `Attempted to add :${emojiName}: reaction. Check server logs for details.`,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private routineGarbageCollection(): void {
    //  at this time we're doing nothing.
    // we need to figure out how garbage collection will work in
    // conversations and how that impacts us (mapping slack conversation to internal conversation)
  }

  /**
   * Determine conversation context based on Slack event
   */
  private determineConversationContext(event: any): ConversationContext {
    const isThreadMessage = !!event.thread_ts;
    const slackThreadTs = isThreadMessage ? event.thread_ts : event.ts;

    if (!isThreadMessage) {
      // Mention in main channel ‚Üí Create new conversation and track thread
      return {
        type: 'channel_mention',
        action: 'Creating',
        slackThreadTs: event.ts,
        responseThreadTs: event.ts, // Start new thread with this message
        isNewConversation: true,
      };
    }

    // This is a thread message - check if we have an existing conversation for this thread
    const existingConversationId =
      this.slackThreadToConversationMap[event.thread_ts];

    if (existingConversationId) {
      // Mention in our existing thread ‚Üí Add to existing conversation
      return {
        type: 'thread_reply',
        action: 'Adding to existing',
        conversationId: existingConversationId,
        slackThreadTs: event.thread_ts,
        responseThreadTs: event.thread_ts,
        isNewConversation: false,
      };
    } else {
      // Mention in external thread ‚Üí Create new conversation
      return {
        type: 'external_thread',
        action: 'Creating',
        slackThreadTs: event.thread_ts,
        responseThreadTs: event.thread_ts,
        isNewConversation: true,
      };
    }
  }

  /**
   * Create or get conversation based on context
   */
  private async getOrCreateConversationForContext(
    context: ConversationContext,
    userId: string,
  ): Promise<Conversation> {
    if (context.action === 'Adding to existing' && context.conversationId) {
      // Try to get existing conversation
      const conversations = await this.chatManagerService.getConversations();

      //      WE SHOULD NOT BE SEARCHING OVER ALL CONVERSATIONS - THAT IS A FUNCTION OF THE SERVICES

      const existingConversation = conversations.find(
        (c) => c.id === context.conversationId,
      );

      if (existingConversation) {
        return existingConversation;
      } else {
        this.logger.log(
          `Expected existing conversation not found, creating new one`,
        );
      }
    }

    // Create new conversation - let ChatManager generate the ID
    const displayName = this.getDisplayNameForContext(context);

    const conversation = await this.chatManagerService.startConversation({
      createdBy: userId,
      createdByRole: UserRole.CUSTOMER,
      title: displayName,
      description: `Slack conversation from ${context.type}`,
      initialParticipants: [userId],
    });

    // Map the Slack thread to this conversation ID for future lookups
    this.slackThreadToConversationMap[context.slackThreadTs] = conversation.id;
    // this.slackThreadToConversationMap.set(
    //   context.slackThreadTs,
    //   conversation.id,
    // );

    this.logger.log(`Created new conversation: ${conversation.id}`);
    this.logger.log(
      `Mapped Slack thread ${context.slackThreadTs} to conversation ${conversation.id}`,
    );

    return conversation;
  }

  /**
   * Generate display name for conversation context
   */
  private getDisplayNameForContext(context: ConversationContext): string {
    switch (context.type) {
      case 'channel_mention':
        return `Slack Channel Conversation`;
      case 'thread_reply':
        return `Slack Thread (Continued)`;
      case 'external_thread':
        return `Slack Thread (New)`;
      default:
        return 'Slack Conversation';
    }
  }
}
