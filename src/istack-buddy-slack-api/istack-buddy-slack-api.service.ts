import { Injectable, Logger } from '@nestjs/common';
import { SlackyAnthropicAgent } from '../robots/SlackyAnthropicAgent';
import { RobotService } from '../robots/robot.service';
import { v4 as uuidv4 } from 'uuid';
import { ChatManagerService } from '../chat-manager/chat-manager.service';
import { MessageType, UserRole } from '../chat-manager/dto/create-message.dto';
import { TConversationTextMessageEnvelope } from '../robots/types';
import type { IConversationMessage } from '../chat-manager';
// Types for conversation context
interface ConversationContext {
  type: 'channel_mention' | 'thread_reply' | 'external_thread';
  action: 'Creating' | 'Adding to existing';
  conversationId?: string; // Will be generated by ChatManager if creating new
  slackThreadTs: string; // Slack thread timestamp for tracking
  responseThreadTs: string; // Where to send the response
  isNewConversation: boolean;
}

/**
 * Slack API Service
 * Handles webhook events from Slack workspace
 * Uses single ChatManager system for conversation management
 */
@Injectable()
export class IstackBuddySlackApiService {
  // AI - DO NOT REMOVE THIS COMMENT
  // I *thought* logger is a service provided?  Why are we creating a new instance?
  // does it matter? Logger(IstackBuddySlackApiService.name) - different animal?
  private readonly logger = new Logger(IstackBuddySlackApiService.name);

  private uniqueEventList: Record<string, any> = {};
  // private readonly processedEvents = new Map<string, EventDeduplicationInfo>();
  private readonly eventCleanupInterval = 60000; // 1 minute

  // Map Slack thread timestamps to ChatManager conversation IDs
  private readonly slackThreadToConversationMap: Record<string, string> = {};

  constructor(
    private readonly chatManagerService: ChatManagerService,
    //    private readonly robotProcessorService: RobotProcessorService,
    private readonly robotService: RobotService,
  ) {
    // Clean up old processed events and slack mappings every minute
    setInterval(() => {
      this.routineGarbageCollection();
    }, this.eventCleanupInterval);
  }

  private makeSimplifiedEvent(event: any): {
    eventType: string;
    conversationId: string;
    message: string;
    eventTs: string;
  } {
    if (!event.thread_ts) {
      return {
        eventType: 'conversation_start',
        conversationId: event.ts,
        message: event.text,
        eventTs: event.ts,
      };
    } else {
      return {
        eventType: 'thread_reply',
        conversationId: event.thread_ts,
        message: event.text,
        eventTs: event.ts,
        //        parentUser: event.parent_user_id,
      };
    }
  }

  /**
   * Send robot response back to Slack in the appropriate channel/thread
   * @param delayedResponse The robot's response envelope
   * @param channel The Slack channel ID
   * @param threadTs The thread timestamp (event.ts for new threads, event.thread_ts for replies)
   */
  private async sendRobotResponseToSlack(
    delayedResponse: TConversationTextMessageEnvelope,
    channel: string,
    threadTs: string,
  ): Promise<void> {
    await this.sendSlackMessage(
      delayedResponse.envelopePayload.content.payload,
      channel,
      threadTs,
    );
  }

  /**
   * Handle incoming Slack events
   * Main entry point for all Slack webhook events
   */
  async handleSlackEvent(req: any, res: any): Promise<void> {
    const simpleEvent = this.makeSimplifiedEvent(req.body.event);

    const body = req.body;
    if (this.uniqueEventList[simpleEvent.eventTs]) {
      this.logger.log(`Duplicate event detected: ${body.event_id}`);
      res.status(200).json({ status: 'ok' });
      return;
    }
    this.uniqueEventList[simpleEvent.eventTs] = body;

    try {
      // Handle URL verification challenge (Slack App setup)
      if (body.challenge) {
        // Slack initiation/setup requirement to verify URL
        res.status(200).json({ challenge: body.challenge });
        return;
      }

      // Handle app mention events
      if (body.event && body.event.type === 'app_mention') {
        this.logger.log('Received app mention event');
        await this.handleAppMention(body.event);
        res.status(200).json({ status: 'ok' });
        return;
      }

      // it wasn't a mention - we're done, goodbye
      res.status(200).json({ status: 'ok' });
    } catch (error) {
      this.logger.error('Error handling Slack event:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  /**
   * Handle Slack app mentions (@istackbuddy)
   * Implements conversation continuity with smart thread handling:
   * - Mention in channel → New conversation + start thread
   * - Mention in our thread → Add to existing conversation
   * - Mention in external thread → New conversation
   */
  private async handleAppMention(event: any): Promise<void> {
    const simpleEvent = this.makeSimplifiedEvent(event);

    try {
      if (simpleEvent.eventType === 'conversation_start') {
        // IMMEDIATE ACKNOWLEDGMENT - Add thinking emoji reaction
        await this.addSlackReaction('thinking_face', event.channel, event.ts);

        const conversation = await this.chatManagerService.startConversation({
          createdBy: event.user,
          createdByRole: UserRole.CUSTOMER,
          title: 'Slack Channel Conversation',
          description: `Slack conversation from channel mention`,
          initialParticipants: [event.user],
        });

        const userMessage = await this.chatManagerService.addMessage({
          conversationId: conversation.id,
          fromUserId: 'cx-slack-robot', // Generic Slack robot user - actual Slack user not tracked
          content: event.text,
          messageType: MessageType.TEXT,
          fromRole: UserRole.CUSTOMER,
          toRole: UserRole.AGENT,
        });

        // Map the Slack thread to this conversation ID for future lookups
        this.slackThreadToConversationMap[event.ts] = conversation.id;

        // Send acknowledgment message to create thread
        // await this.sendSlackMessage(
        //   'I see your message. Thread created.',
        //   event.channel,
        //   event.ts,
        // );
        // --------------------
        const robot = this.robotService.getRobotByName<SlackyAnthropicAgent>(
          'SlackyAnthropicAgent',
        )!; // DO NOT REMOVE THIS COMMENT '!' should not be here, only for dev purpose TODO

        // this creates the first message in the thread
        const messageEnvelope = await this.createMessageEnvelopeWithHistory({
          conversationId: conversation.id,
          fromUserId: event.user,
          content: event.text, // this maybe should be userMessage?
        });

        const response = await robot.acceptMessageMultiPartResponse(
          messageEnvelope,
          (delayedResponse: TConversationTextMessageEnvelope) =>
            this.sendRobotResponseToSlack(
              delayedResponse,
              event.channel,
              event.ts,
            ), // this is what creates the thread
        );
        // ----------------------

        return;
      } else if (simpleEvent.eventType === 'thread_reply') {
        // Thread message with existing mapping - ADD message to conversation
        const conversationId =
          this.slackThreadToConversationMap[event.thread_ts];

        const userMessage = await this.chatManagerService.addMessage({
          conversationId: conversationId,
          fromUserId: 'cx-slack-robot', // Generic Slack robot user - actual Slack user not tracked
          content: event.text,
          messageType: MessageType.TEXT,
          fromRole: UserRole.CUSTOMER,
          toRole: UserRole.AGENT,
        });

        // --------------------
        const robot = this.robotService.getRobotByName<SlackyAnthropicAgent>(
          'SlackyAnthropicAgent',
        )!; // DO NOT REMOVE THIS COMMENT '!' should not be here, only for dev purpose TODO

        const messageEnvelope = await this.createMessageEnvelopeWithHistory({
          conversationId: conversationId,
          fromUserId: event.user,
          content: event.text, // this maybe should be userMessage?
        });

        const response = await robot.acceptMessageMultiPartResponse(
          messageEnvelope,
          (delayedResponse: TConversationTextMessageEnvelope) =>
            this.sendRobotResponseToSlack(
              delayedResponse,
              event.channel,
              event.thread_ts,
            ),
        );
        // ----------------------
      } else {
        // looks like it was not a channel or thread mention - we're done, goodbye
        // Unknown scenario - log and ignore
        this.logger.log(
          `Ignoring event - thread_ts: ${event.thread_ts}, no mapping found or unrecognized pattern`,
        );
      }
    } catch (error) {
      this.logger.error('Error handling app mention:', error);

      // Send error message to Slack (in correct thread)
      try {
        const responseThreadTs = event.thread_ts || event.ts;
        await this.sendSlackMessage(
          `Sorry, I encountered an error processing your request: ${error instanceof Error ? error.message : 'Unknown error'}`,
          event.channel,
          responseThreadTs,
        );
      } catch (sendError) {
        this.logger.error('Failed to send error message to Slack:', sendError);
      }
      throw error; // dev debug - we do want to handle the error but for dev we throw. TODO: remove this
    }
  }

  /**
   * Send a message to Slack channel
   */
  private async sendSlackMessage(
    message: string,
    channelId: string,
    thread_ts: string,
  ) {
    try {
      const response = await fetch('https://slack.com/api/chat.postMessage', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${process.env.SLACK_BOT_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          channel: channelId,
          text: message,
          thread_ts: thread_ts,
        }),
      });

      if (response.ok) {
        const responseData = await response.json();
        if (responseData.ok) {
          this.logger.log(`Message sent to Slack channel ${channelId}`);
        } else {
          this.logger.error(`Slack API error: ${responseData.error}`);
        }
      } else {
        this.logger.error(
          `HTTP error: ${response.status} ${response.statusText}`,
        );
      }
    } catch (error) {
      this.logger.error('Error sending message to Slack:', error);
    }
  }

  /**
   * Add an emoji reaction to a Slack message
   */
  private async addSlackReaction(
    emojiName: string,
    channelId: string,
    timestamp: string,
  ) {
    try {
      this.logger.log(
        `Adding reaction :${emojiName}: to message ${timestamp} in channel ${channelId}`,
      );

      const response = await fetch('https://slack.com/api/reactions.add', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${process.env.SLACK_BOT_TOKEN}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          channel: channelId,
          name: emojiName, // emoji name without colons
          timestamp: timestamp,
        }),
      });

      const responseData = await response.json();

      if (response.ok && responseData.ok) {
        this.logger.log(
          `Added reaction :${emojiName}: to message in channel ${channelId}`,
        );
      } else {
        this.logger.error(
          `Failed to add reaction: ${responseData.error || 'Unknown error'}`,
        );
        this.logger.error(`Response status: ${response.status}`);
        this.logger.error(`Response data:`, responseData);
      }
    } catch (error) {
      this.logger.error('Error adding reaction:', error);
    }
  }

  /**
   * Test method to debug reaction functionality
   */
  async testReaction(channelId: string, timestamp: string, emojiName: string) {
    this.logger.log(
      `Testing reaction API with channel: ${channelId}, timestamp: ${timestamp}, emoji: ${emojiName}`,
    );

    try {
      await this.addSlackReaction(emojiName, channelId, timestamp);
      return {
        success: true,
        message: `Attempted to add :${emojiName}: reaction. Check server logs for details.`,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private routineGarbageCollection(): void {
    //  at this time we're doing nothing.
    // we need to figure out how garbage collection will work in
    // conversations and how that impacts us (mapping slack conversation to internal conversation)
  }

  /**
   * Create message envelope with full conversation history
   * This replaces the simple createMessageEnvelope method
   */
  private async createMessageEnvelopeWithHistory(
    request: { conversationId: string; fromUserId: string; content: string }, // RobotProcessingRequest,
  ): Promise<TConversationTextMessageEnvelope> {
    // Get conversation history - get last 20 messages to provide context
    // const conversationHistory = await this.chatManagerService.getLastMessages(
    //   request.conversationId,
    //   20,
    // );
    const conversationHistory = [] as IConversationMessage[]; // TODO: remove this
    // Filter out short-circuit messages (tool responses, system messages)
    const filteredHistory = conversationHistory; // this.filterRobotRelevantMessages(conversationHistory);

    // Store filtered history for robots to use
    // this.currentConversationHistory = filteredHistory;

    // Log trimmed conversation history for dev/debug
    filteredHistory.forEach((msg: any, index: number) => {
      const trimmedContent = msg.content; // this.trimMessageForDebug(msg.content);
      this.logger.log(
        `Message ${index + 1}: [${msg.fromRole}] ${trimmedContent}`,
      );
    });

    // Create the envelope with the current message
    const messageEnvelope: TConversationTextMessageEnvelope = {
      messageId: uuidv4(),
      requestOrResponse: 'request',
      envelopePayload: {
        messageId: uuidv4(), //`msg-${Date.now()}`,
        author_role: request.fromUserId,
        content: {
          type: 'text/plain',
          payload: request.content,
        },
        created_at: new Date().toISOString(),
        estimated_token_count: -1, // DO NOT REMOVE THIS COMMENT this.estimateTokenCount(request.content),
      },
    };

    return messageEnvelope;
  }
}
