import * as dotenv from 'dotenv';
import { RobotChatOpenAI } from '../../../src/robots/RobotChatOpenAI';
import {
  TConversationTextMessageEnvelope,
  TConversationTextMessage,
} from '../../../src/robots/types';
import {
  UserRole,
  MessageType,
} from '../../../src/chat-manager/dto/create-message.dto';
import { IConversationMessage } from '../../../src/chat-manager/interfaces/message.interface';
import { CustomLoggerService } from '../../../src/common/logger/custom-logger.service';

// Load environment variables from .env.live
dotenv.config({ path: '.env.live' });

// Set log level to silence debug logs
process.env.LOG_LEVEL = 'error';

async function testStreaming() {
  console.log('Starting OpenAI streaming test with conversation history...\n');

  // Temporarily silence all NestJS debug logs
  const originalConsole = { ...console };
  console.log = (...args) => {
    const message = args.join(' ');
    if (!message.includes('[Nest]')) {
      originalConsole.log(...args);
    }
  };
  console.error = (...args) => {
    const message = args.join(' ');
    if (!message.includes('[Nest]')) {
      originalConsole.error(...args);
    }
  };
  console.debug = (...args) => {
    const message = args.join(' ');
    if (!message.includes('[Nest]')) {
      originalConsole.debug(...args);
    }
  };

  // Create a silent logger to avoid NestJS debug output

  const robot = new RobotChatOpenAI();

  // Temporarily redirect stdout to filter NestJS logs
  const originalStdout = process.stdout.write;
  process.stdout.write = (chunk: any, ...args: any[]) => {
    const message = chunk.toString();
    if (!message.includes('[Nest]')) {
      return originalStdout.call(process.stdout, chunk, ...args);
    }
    return true;
  };

  // Simulate conversation history
  const conversationHistory: IConversationMessage[] = [
    {
      id: 'msg-1',
      conversationId: 'test-conversation',
      fromUserId: 'user',
      fromRole: UserRole.CUSTOMER,
      toRole: UserRole.ROBOT,
      content:
        'we are testing/debugging. Return a random number and a thought of the day',
      messageType: MessageType.TEXT,
      createdAt: new Date(Date.now() - 60000), // 1 minute ago
      updatedAt: new Date(Date.now() - 60000),
    },
    {
      id: 'msg-2',
      conversationId: 'test-conversation',
      fromUserId: 'robot',
      fromRole: UserRole.ROBOT,
      toRole: UserRole.CUSTOMER,
      content:
        'Here is your random number: 42 and a thought of the day: "Every day is a new opportunity to learn something amazing!"',
      messageType: MessageType.TEXT,
      createdAt: new Date(Date.now() - 30000), // 30 seconds ago
      updatedAt: new Date(Date.now() - 30000),
    },
  ];

  // Create the second message envelope (user's follow-up question)
  const followUpMessage: TConversationTextMessage = {
    messageId: `test-${Date.now()}`,
    author_role: 'user',
    content: {
      type: 'text/plain',
      payload:
        'Please use the fsRestrictedApiFormAndRelatedEntityOverview tool to get information about form 12345',
    },
    created_at: new Date().toISOString(),
    estimated_token_count: 20,
  };

  const messageEnvelope: TConversationTextMessageEnvelope = {
    messageId: `envelope-${Date.now()}`,
    requestOrResponse: 'request',
    envelopePayload: followUpMessage,
  };

  console.log('=== Conversation History ===');
  conversationHistory.forEach((msg, index) => {
    console.log(`${index + 1}. [${msg.fromRole}] ${msg.content}`);
  });
  console.log();

  console.log(
    `=== Current Message ===\n[user] ${followUpMessage.content.payload}\n`,
  );

  console.log('=== Streaming Response ===');

  // Call the streaming function with conversation history
  await robot.acceptMessageStreamResponse(
    messageEnvelope,
    (chunk: string) => {
      process.stdout.write(`chunk: ${chunk}`);
    },
    () => conversationHistory, // Pass conversation history
  );

  console.log('\nStreaming test completed!');
}

// Run the test
testStreaming().catch(console.error);
